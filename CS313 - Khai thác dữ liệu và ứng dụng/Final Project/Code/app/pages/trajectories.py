# pages/3_Trajectory_Visualization.py
import streamlit as st
import pandas as pd
import geopandas as gpd
import folium
from streamlit_folium import folium_static
import random
import numpy as np
# import matplotlib.colors as mcolors # Kh√¥ng c·∫ßn cho m√†u ng·∫´u nhi√™n ƒë∆°n gi·∫£n n·ªØa
from shapely.geometry import LineString

# --- H√†m ti·ªán √≠ch ---
def get_random_html_color():
    """T·∫°o m·ªôt m√£ m√†u HTML ng·∫´u nhi√™n."""
    return "#{:06x}".format(random.randint(0, 0xFFFFFF))

# --- H√†m ch√≠nh c·ªßa trang ---
def trajectory_visualization_page():
    st.set_page_config(page_title="Trajectory Visualization", layout="wide")
    st.title("üõ∞Ô∏è Interactive Trajectory Visualization")

    if 'gdf_data' not in st.session_state or st.session_state.gdf_data.empty:
        st.warning("‚ö†Ô∏è Vui l√≤ng t·∫£i d·ªØ li·ªáu l√™n t·ª´ trang ch√≠nh (app.py) tr∆∞·ªõc.")
        return

    gdf_single_file = st.session_state.gdf_data.copy()

    st.sidebar.header("üöÄ Trajectory Options")

    # --- Ch·ªçn c·ªôt ƒë·ªãnh danh v√† timestamp (Gi·ªØ nguy√™n logic c≈©) ---
    available_columns = gdf_single_file.columns.tolist()
    default_id_col_candidates = ['generated_individual_id', 'individual-local-identifier', 'tag-local-identifier']
    default_id_col = next((col for col in default_id_col_candidates if col in available_columns), None)
    if default_id_col is None and available_columns:
        default_id_col = available_columns[0]

    default_ts_col = 'timestamp' if 'timestamp' in available_columns else None
    if default_ts_col is None and len(available_columns) > 1:
         default_ts_col = available_columns[1] if default_id_col != available_columns[1] else (available_columns[0] if len(available_columns)>0 and default_id_col != available_columns[0] else None)

    id_column = st.sidebar.selectbox(
        "C·ªôt ƒë·ªãnh danh c√° th·ªÉ (Individual Identifier):",
        options=available_columns,
        index=(available_columns.index(default_id_col) if default_id_col and default_id_col in available_columns else 0),
        key="traj_single_id_col_v2" # ƒê·ªïi key ƒë·ªÉ tr√°nh xung ƒë·ªôt n·∫øu c√≥ state c≈©
    )
    timestamp_column = st.sidebar.selectbox(
        "C·ªôt th·ªùi gian (Timestamp):",
        options=available_columns,
        index=(available_columns.index(default_ts_col) if default_ts_col and default_ts_col in available_columns else (1 if len(available_columns)>1 else 0) ),
        key="traj_single_ts_col_v2" # ƒê·ªïi key
    )

    if not id_column or not timestamp_column:
        st.error("Vui l√≤ng ch·ªçn c·∫£ c·ªôt ƒë·ªãnh danh v√† c·ªôt th·ªùi gian."); return
    if id_column == timestamp_column:
        st.error("C·ªôt ƒë·ªãnh danh v√† c·ªôt th·ªùi gian kh√¥ng ƒë∆∞·ª£c tr√πng nhau."); return

    # --- X·ª≠ l√Ω timestamp v√† s·∫Øp x·∫øp (Gi·ªØ nguy√™n logic c≈©) ---
    try:
        gdf_processed = gdf_single_file.copy()
        gdf_processed[timestamp_column] = pd.to_datetime(gdf_processed[timestamp_column], errors='coerce')
        gdf_processed.dropna(subset=[timestamp_column], inplace=True)
    except Exception as e:
        st.error(f"L·ªói chuy·ªÉn ƒë·ªïi c·ªôt th·ªùi gian '{timestamp_column}': {e}. ƒê·∫£m b·∫£o c·ªôt c√≥ ƒë·ªãnh d·∫°ng ng√†y gi·ªù h·ª£p l·ªá."); return
    if gdf_processed.empty:
        st.warning("Kh√¥ng c√≤n d·ªØ li·ªáu sau khi x·ª≠ l√Ω timestamp ho·∫∑c d·ªØ li·ªáu ƒë·∫ßu v√†o r·ªóng."); return
    try:
        gdf_sorted = gdf_processed.sort_values(by=[id_column, timestamp_column])
    except KeyError as e:
        st.error(f"L·ªói khi s·∫Øp x·∫øp d·ªØ li·ªáu. C·ªôt '{str(e)}' kh√¥ng t·ªìn t·∫°i. Vui l√≤ng ki·ªÉm tra l·∫°i l·ª±a ch·ªçn c·ªôt.")
        return

    # --- L·ªçc theo kho·∫£ng th·ªùi gian (Gi·ªØ nguy√™n logic c≈©, c√≥ th·ªÉ c·∫ßn key m·ªõi cho session state) ---
    st.sidebar.markdown("---")
    st.sidebar.subheader("‚è≥ L·ªçc theo Th·ªùi gian")
    if gdf_sorted.empty or not pd.api.types.is_datetime64_any_dtype(gdf_sorted[timestamp_column]):
        st.sidebar.warning("Kh√¥ng th·ªÉ x√°c ƒë·ªãnh kho·∫£ng th·ªùi gian t·ª´ d·ªØ li·ªáu hi·ªán t·∫°i.")
    else:
        min_date_available = gdf_sorted[timestamp_column].min().date()
        max_date_available = gdf_sorted[timestamp_column].max().date()
        start_date_key_v2 = 'traj_single_date_filter_start_v2'
        end_date_key_v2 = 'traj_single_date_filter_end_v2'

        if start_date_key_v2 not in st.session_state or st.session_state[start_date_key_v2] < min_date_available or st.session_state[start_date_key_v2] > max_date_available:
            st.session_state[start_date_key_v2] = min_date_available
        if end_date_key_v2 not in st.session_state or st.session_state[end_date_key_v2] < min_date_available or st.session_state[end_date_key_v2] > max_date_available:
            st.session_state[end_date_key_v2] = max_date_available
        if st.session_state[start_date_key_v2] > st.session_state[end_date_key_v2] :
             st.session_state[start_date_key_v2] = st.session_state[end_date_key_v2]

        start_date_filter = st.sidebar.date_input("Ng√†y b·∫Øt ƒë·∫ßu", value=st.session_state[start_date_key_v2],
                                                min_value=min_date_available, max_value=max_date_available,
                                                key="traj_single_start_date_picker_v2")
        end_date_filter = st.sidebar.date_input("Ng√†y k·∫øt th√∫c", value=st.session_state[end_date_key_v2],
                                              min_value=min_date_available, max_value=max_date_available,
                                              key="traj_single_end_date_picker_v2")
        if start_date_filter > end_date_filter:
            st.sidebar.error("Ng√†y b·∫Øt ƒë·∫ßu kh√¥ng ƒë∆∞·ª£c l·ªõn h∆°n ng√†y k·∫øt th√∫c.")
        else:
            st.session_state[start_date_key_v2] = start_date_filter
            st.session_state[end_date_key_v2] = end_date_filter
            start_datetime = pd.to_datetime(start_date_filter)
            end_datetime = pd.to_datetime(end_date_filter) + pd.Timedelta(days=1) - pd.Timedelta(seconds=1)
            gdf_sorted = gdf_sorted[(gdf_sorted[timestamp_column] >= start_datetime) & (gdf_sorted[timestamp_column] <= end_datetime)]
            if gdf_sorted.empty:
                st.info(f"Kh√¥ng c√≥ qu·ªπ ƒë·∫°o n√†o trong kho·∫£ng th·ªùi gian t·ª´ {start_date_filter.strftime('%Y-%m-%d')} ƒë·∫øn {end_date_filter.strftime('%Y-%m-%d')}.")

    # --- L·ªçc c√° th·ªÉ v√† gi·ªõi h·∫°n qu·ªπ ƒë·∫°o (Gi·ªØ nguy√™n logic c≈©, c√≥ th·ªÉ c·∫ßn key m·ªõi) ---
    unique_ids = gdf_sorted[id_column].unique() if not gdf_sorted.empty else np.array([])
    if len(unique_ids) == 0: st.warning("Kh√¥ng c√≥ c√° th·ªÉ n√†o sau khi l·ªçc."); return

    st.sidebar.markdown("---")
    st.sidebar.subheader("üéØ L·ªçc & Hi·ªÉn th·ªã Qu·ªπ ƒë·∫°o")
    select_all_individuals = st.sidebar.checkbox("Hi·ªÉn th·ªã t·∫•t c·∫£ c√° th·ªÉ", value=True, key="traj_single_select_all_ids_v2")
    ids_to_plot_options = sorted(unique_ids.tolist())
    if select_all_individuals:
        selected_individual_ids = ids_to_plot_options
    else:
        selected_individual_ids = st.sidebar.multiselect("Ch·ªçn (c√°c) c√° th·ªÉ:", options=ids_to_plot_options, default=ids_to_plot_options[0] if ids_to_plot_options else [], key="traj_single_multiselect_ids_v2")
    if not selected_individual_ids: st.info("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt c√° th·ªÉ."); return
    
    max_total_trajectories = st.sidebar.slider("S·ªë qu·ªπ ƒë·∫°o t·ªëi ƒëa hi·ªÉn th·ªã:", 1, max(1, len(selected_individual_ids)), min(50, len(selected_individual_ids)) if selected_individual_ids else 1, 1, key="traj_single_max_total_v2")

    # --- T√ôY CH·ªåN HI·ªÇN TH·ªä MARKER ƒêI·ªÇM ƒê·∫¶U/CU·ªêI (T√çNH NƒÇNG M·ªöI) ---
    show_start_end_markers = st.sidebar.checkbox("Hi·ªÉn th·ªã ƒëi·ªÉm B·∫Øt ƒë·∫ßu/K·∫øt th√∫c", value=True, key="traj_show_markers")
    st.sidebar.markdown("---")


    # --- T·∫°o b·∫£n ƒë·ªì (Gi·ªØ nguy√™n logic c≈©) ---
    map_data_filtered_by_id = gdf_sorted[gdf_sorted[id_column].isin(selected_individual_ids)]
    if not map_data_filtered_by_id.empty:
        map_center_lat = map_data_filtered_by_id.geometry.y.mean(); map_center_lon = map_data_filtered_by_id.geometry.x.mean(); initial_zoom = 6
    else:
        map_center_lat = gdf_single_file.geometry.y.mean() if not gdf_single_file.empty else 0
        map_center_lon = gdf_single_file.geometry.x.mean() if not gdf_single_file.empty else 0
        initial_zoom = 2
        if selected_individual_ids : st.warning("Kh√¥ng c√≥ d·ªØ li·ªáu cho c√°c c√° th·ªÉ ƒë√£ ch·ªçn sau khi l·ªçc.")

    m = folium.Map(location=[map_center_lat, map_center_lon], zoom_start=initial_zoom, tiles="CartoDB positron")
    total_trajectories_plotted = 0
    plotted_trajectories_info = []
    ids_actually_plotting = selected_individual_ids[:max_total_trajectories]

    for individual_id in ids_actually_plotting:
        trajectory_data = map_data_filtered_by_id[map_data_filtered_by_id[id_column] == individual_id].sort_values(by=timestamp_column)
        if len(trajectory_data) < 1: continue # C·∫ßn √≠t nh·∫•t 1 ƒëi·ªÉm ƒë·ªÉ c√≥ th·ªÉ c√≥ marker, 2 ƒë·ªÉ c√≥ line

        points = list(zip(trajectory_data.geometry.y, trajectory_data.geometry.x))
        line_color = get_random_html_color()
        start_time = trajectory_data[timestamp_column].min()
        end_time = trajectory_data[timestamp_column].max()
        duration = end_time - start_time
        num_points = len(points)
        length_str = "N/A"
        try:
            line_geom_for_length = LineString(trajectory_data.geometry.apply(lambda p: (p.x, p.y)).tolist())
            if not line_geom_for_length.is_empty: # Ki·ªÉm tra n·∫øu LineString kh√¥ng r·ªóng
                 projected_line = gpd.GeoSeries([line_geom_for_length], crs="EPSG:4326").to_crs("EPSG:3857")
                 length_meters = projected_line.length.iloc[0]
                 length_str = f"{length_meters/1000:.2f} km" if length_meters > 0 else "0 km"
        except Exception: pass

        popup_html = f"""<b>ID C√° th·ªÉ:</b> {individual_id}<br><b>S·ªë ƒëi·ªÉm:</b> {num_points}<br>
                         <b>B·∫Øt ƒë·∫ßu:</b> {start_time.strftime('%Y-%m-%d %H:%M:%S')}<br>
                         <b>K·∫øt th√∫c:</b> {end_time.strftime('%Y-%m-%d %H:%M:%S')}<br>
                         <b>Th·ªùi gian bay:</b> {str(duration).split('.')[0]} (HH:MM:SS)<br>
                         <b>Chi·ªÅu d√†i (∆∞·ªõc t√≠nh):</b> {length_str}"""
        
        # V·∫Ω ƒë∆∞·ªùng qu·ªπ ƒë·∫°o n·∫øu c√≥ ƒë·ªß ƒëi·ªÉm
        if num_points >= 2:
            folium.PolyLine(
                points, color=line_color, tooltip=f"<b>ID:</b> {individual_id}<br><b>ƒêi·ªÉm:</b> {num_points}",
                popup=folium.Popup(popup_html, max_width=350), weight=2.5, opacity=0.8
            ).add_to(m)

        # --- TH√äM MARKER ƒêI·ªÇM ƒê·∫¶U V√Ä CU·ªêI (T√çNH NƒÇNG M·ªöI) ---
        if show_start_end_markers and points: # ƒê·∫£m b·∫£o c√≥ `points`
            # ƒêi·ªÉm b·∫Øt ƒë·∫ßu
            folium.Marker(
                location=points[0],
                popup=f"<b>B·∫Øt ƒë·∫ßu: {individual_id}</b><br>{start_time.strftime('%Y-%m-%d %H:%M:%S')}",
                tooltip=f"B·∫Øt ƒë·∫ßu: {individual_id}",
                icon=folium.Icon(color='green', icon='play', prefix='fa') # Font Awesome icon
            ).add_to(m)

            # ƒêi·ªÉm k·∫øt th√∫c (ch·ªâ th√™m n·∫øu c√≥ nhi·ªÅu h∆°n 1 ƒëi·ªÉm ƒë·ªÉ ph√¢n bi·ªát v·ªõi ƒëi·ªÉm b·∫Øt ƒë·∫ßu)
            if num_points > 1:
                folium.Marker(
                    location=points[-1],
                    popup=f"<b>K·∫øt th√∫c: {individual_id}</b><br>{end_time.strftime('%Y-%m-%d %H:%M:%S')}",
                    tooltip=f"K·∫øt th√∫c: {individual_id}",
                    icon=folium.Icon(color='red', icon='stop', prefix='fa') # Font Awesome icon
                ).add_to(m)
            # N·∫øu ch·ªâ c√≥ 1 ƒëi·ªÉm, marker b·∫Øt ƒë·∫ßu ƒë√£ ƒë·ªß
            elif num_points == 1 : # Tr∆∞·ªùng h·ª£p qu·ªπ ƒë·∫°o ch·ªâ c√≥ 1 ƒëi·ªÉm (ch·ªâ v·∫Ω marker b·∫Øt ƒë·∫ßu)
                 pass # Marker b·∫Øt ƒë·∫ßu ƒë√£ ƒë∆∞·ª£c v·∫Ω ·ªü tr√™n

        total_trajectories_plotted += 1
        plotted_trajectories_info.append({
            "Individual ID": individual_id, "Points": num_points, "Start Time": start_time,
            "End Time": end_time, "Duration": str(duration).split('.')[0],
            "Length (km, approx.)": length_str if length_str != "N/A" else None,
            "_Color_HTML_": f"<div style='width:15px; height:15px; background-color:{line_color if num_points >=2 else '#808080'}; border-radius:50%;'></div>" # M√†u x√°m n·∫øu ch·ªâ c√≥ 1 ƒëi·ªÉm
        })

    # --- Hi·ªÉn th·ªã b·∫£n ƒë·ªì v√† b·∫£ng th√¥ng tin (Gi·ªØ nguy√™n logic c≈©) ---
    if total_trajectories_plotted > 0:
        st.info(f"Hi·ªÉn th·ªã {total_trajectories_plotted} qu·ªπ ƒë·∫°o (ƒë√£ l·ªçc v√† gi·ªõi h·∫°n).")
        folium_static(m, height=650) # B·ªè width="100%"
        st.subheader("üìú Th√¥ng tin c√°c qu·ªπ ƒë·∫°o ƒëang hi·ªÉn th·ªã:")
        df_display = pd.DataFrame(plotted_trajectories_info)
        df_display_cols = ["Individual ID", "Points", "Start Time", "End Time", "Duration", "Length (km, approx.)", "_Color_HTML_"]
        df_display = df_display[[col for col in df_display_cols if col in df_display.columns]]
        if 'Start Time' in df_display: df_display['Start Time'] = df_display['Start Time'].dt.strftime('%Y-%m-%d %H:%M')
        if 'End Time' in df_display: df_display['End Time'] = df_display['End Time'].dt.strftime('%Y-%m-%d %H:%M')
        # D√≤ng 217 trong t·ªáp D:\Data-Mining-UIT\app\pages\trajectories.py
        st.dataframe(df_display, use_container_width=True, hide_index=True,
                    column_config={"_Color_HTML_": st.column_config.TextColumn(label="M√†u")})
    else: st.info("Kh√¥ng c√≥ qu·ªπ ƒë·∫°o n√†o ƒë·ªÉ hi·ªÉn th·ªã d·ª±a tr√™n c√°c l·ª±a ch·ªçn hi·ªán t·∫°i.")

if __name__ == "__main__":
    trajectory_visualization_page()